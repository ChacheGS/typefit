from functools import wraps
from inspect import signature
from typing import Any, Callable, Dict, Optional, Text, Type, Union
from urllib.parse import urljoin

import httpx
import httpx.models as hm

from .fitting import T, typefit
from .utils import UrlFormatter, callable_value

HeadersFactory = Callable[..., hm.HeaderTypes]
Headers = Union[None, hm.HeaderTypes, HeadersFactory]

PathFactory = Callable[..., Text]
Path = Union[PathFactory, Text]

Params = Optional[hm.QueryParamTypes]


def get(path: Path, params: Params = None, headers: Headers = None, hint: Any = None):
    """
    Generates an API method that GET the URL, based on provided parameters and
    method signature. The decorated method's code will never be called, only
    the generated method will be used.
    """

    def decorator(func: Callable):
        sig = signature(func)

        if len(sig.parameters) == 0:
            raise TypeError("Decorated function doesn't have any arguments")

        @wraps(func)
        def wrapper(*args, **kwargs):
            """
            Gets the signature from the decorated function and applies the
            arguments received from the call. If the arguments are no good then
            it will fail.

            Then uses the helper's get method in order to generate the actual
            request and arguments.

            The real method is never called.
            """

            bound = sig.bind(*args, **kwargs)
            bound.apply_defaults()

            self = next(iter(bound.arguments.values()))

            if not isinstance(self, SyncClient):
                raise TypeError(f"{self!r} is not a SyncClient")

            return self.helper.get(
                path=path,
                params=params,
                headers=headers,
                hint=hint,
                kwargs=bound.arguments,
                data_type=sig.return_annotation,
            )

        return wrapper

    return decorator


class _SyncClientHelper:
    """
    Effector for all requests and parameters generation. It's separated from
    the client itself for readability regarding what should or should not be
    overridden.
    """

    def __init__(self, client: "SyncClient"):
        self.client = client
        self.http = httpx.Client()

    def url(self, path: Path, kwargs: Dict[Text, Any]):
        """
        Generates the URL using urljoin in the client's BASE_URL and the
        provided path. The path could be a callable, if so it will be called
        using loose_call and the provided kwargs.
        """

        f = UrlFormatter()
        url = urljoin(self.client.BASE_URL, callable_value(path, kwargs))
        return f.format(url, **kwargs)

    def headers(self, extra: Headers, kwargs: Dict[Text, Any]) -> hm.Headers:
        """
        Generates the headers for this request. It will:

        1. Get the default headers as generated by the client's headers()
           method
        2. Use the specific extra headers specified via the decorator. Callable
           values will be called before being returned.

        All of that is merged and returned.
        """

        out = hm.Headers(self.client.headers())
        out.update(callable_value(extra, kwargs))

        return out

    def get(
        self,
        kwargs: Dict[Text, Any],
        data_type: Type[T],
        path: Text,
        headers: Headers = None,
        params: Params = None,
        hint: Any = None,
    ) -> T:
        """
        This will do the GET query and fit it into the data.
        """

        r = self.http.get(
            url=self.url(path, kwargs),
            headers=self.headers(headers, kwargs),
            params=callable_value(params, kwargs),
        )
        self.client.raise_errors(r, hint)
        data = self.client.decode(r, hint)
        data = self.client.extract(data, hint)

        return typefit(data_type, data)


class SyncClient:
    """
    SyncClient base class. To create your own API client, inherit from this
    and generate your methods using the HTTP decorators found above.
    """

    BASE_URL = ""

    def __init__(self):
        self.helper = _SyncClientHelper(self)

    def headers(self) -> Optional[hm.HeaderTypes]:
        """
        Inherit this to generate headers that will be sent at each request.
        """

    def raise_errors(self, resp: httpx.Response, hint: Any) -> None:
        """
        By default, raise errors if HTTP statuses are error status but you
        could do any kind of inspection you want here.

        The hint is there in case you need different mechanisms for different
        paths, the hint is provided through the decorator.
        """

        resp.raise_for_status()

    def decode(self, resp: httpx.Response, hint: Any) -> Any:
        """
        Transforms the HTTP response into viable data. By default it decodes
        JSON but who knows what you might want to support.

        The hint is there in case you need different mechanisms for different
        paths, the hint is provided through the decorator.
        """

        return resp.json()

    def extract(self, data: Any, hint: Any) -> Any:
        """
        Use this method to extract the data before fitting it into a type. By
        example, sometimes APIs will return something like {result: xxx}
        instead of returning your object directly.

        The hint is there in case you need different mechanisms for different
        paths, the hint is provided through the decorator.
        """

        return data
